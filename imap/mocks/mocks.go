// Code generated by MockGen. DO NOT EDIT.
// Source: ../types.go

// Package mock_imap is a generated GoMock package.
package mock_imap

import (
	reflect "reflect"
	time "time"

	imap "github.com/emersion/go-imap"
	client "github.com/emersion/go-imap/client"
	sasl "github.com/emersion/go-sasl"
	gomock "github.com/golang/mock/gomock"
	imap0 "github.com/vs49688/mailpump/imap"
)

// MockClient is a mock of Client interface.
type MockClient struct {
	ctrl     *gomock.Controller
	recorder *MockClientMockRecorder
}

// MockClientMockRecorder is the mock recorder for MockClient.
type MockClientMockRecorder struct {
	mock *MockClient
}

// NewMockClient creates a new mock instance.
func NewMockClient(ctrl *gomock.Controller) *MockClient {
	mock := &MockClient{ctrl: ctrl}
	mock.recorder = &MockClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClient) EXPECT() *MockClientMockRecorder {
	return m.recorder
}

// Append mocks base method.
func (m *MockClient) Append(mbox string, flags []string, date time.Time, msg imap.Literal) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Append", mbox, flags, date, msg)
	ret0, _ := ret[0].(error)
	return ret0
}

// Append indicates an expected call of Append.
func (mr *MockClientMockRecorder) Append(mbox, flags, date, msg interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Append", reflect.TypeOf((*MockClient)(nil).Append), mbox, flags, date, msg)
}

// Expunge mocks base method.
func (m *MockClient) Expunge(ch chan uint32) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Expunge", ch)
	ret0, _ := ret[0].(error)
	return ret0
}

// Expunge indicates an expected call of Expunge.
func (mr *MockClientMockRecorder) Expunge(ch interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Expunge", reflect.TypeOf((*MockClient)(nil).Expunge), ch)
}

// Fetch mocks base method.
func (m *MockClient) Fetch(seqset *imap.SeqSet, items []imap.FetchItem, ch chan *imap.Message) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Fetch", seqset, items, ch)
	ret0, _ := ret[0].(error)
	return ret0
}

// Fetch indicates an expected call of Fetch.
func (mr *MockClientMockRecorder) Fetch(seqset, items, ch interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fetch", reflect.TypeOf((*MockClient)(nil).Fetch), seqset, items, ch)
}

// FlagQuit mocks base method.
func (m *MockClient) FlagQuit() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "FlagQuit")
}

// FlagQuit indicates an expected call of FlagQuit.
func (mr *MockClientMockRecorder) FlagQuit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlagQuit", reflect.TypeOf((*MockClient)(nil).FlagQuit))
}

// Idle mocks base method.
func (m *MockClient) Idle(stop <-chan struct{}, opts *client.IdleOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Idle", stop, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// Idle indicates an expected call of Idle.
func (mr *MockClientMockRecorder) Idle(stop, opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Idle", reflect.TypeOf((*MockClient)(nil).Idle), stop, opts)
}

// LoggedOut mocks base method.
func (m *MockClient) LoggedOut() <-chan struct{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoggedOut")
	ret0, _ := ret[0].(<-chan struct{})
	return ret0
}

// LoggedOut indicates an expected call of LoggedOut.
func (mr *MockClientMockRecorder) LoggedOut() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoggedOut", reflect.TypeOf((*MockClient)(nil).LoggedOut))
}

// Logout mocks base method.
func (m *MockClient) Logout() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Logout")
	ret0, _ := ret[0].(error)
	return ret0
}

// Logout indicates an expected call of Logout.
func (mr *MockClientMockRecorder) Logout() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logout", reflect.TypeOf((*MockClient)(nil).Logout))
}

// Mailbox mocks base method.
func (m *MockClient) Mailbox() *imap.MailboxStatus {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Mailbox")
	ret0, _ := ret[0].(*imap.MailboxStatus)
	return ret0
}

// Mailbox indicates an expected call of Mailbox.
func (mr *MockClientMockRecorder) Mailbox() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Mailbox", reflect.TypeOf((*MockClient)(nil).Mailbox))
}

// Select mocks base method.
func (m *MockClient) Select(name string, readOnly bool) (*imap.MailboxStatus, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Select", name, readOnly)
	ret0, _ := ret[0].(*imap.MailboxStatus)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Select indicates an expected call of Select.
func (mr *MockClientMockRecorder) Select(name, readOnly interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockClient)(nil).Select), name, readOnly)
}

// UidStore mocks base method.
func (m *MockClient) UidStore(seqset *imap.SeqSet, item imap.StoreItem, value interface{}, ch chan *imap.Message) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UidStore", seqset, item, value, ch)
	ret0, _ := ret[0].(error)
	return ret0
}

// UidStore indicates an expected call of UidStore.
func (mr *MockClientMockRecorder) UidStore(seqset, item, value, ch interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UidStore", reflect.TypeOf((*MockClient)(nil).UidStore), seqset, item, value, ch)
}

// MockAuthenticatable is a mock of Authenticatable interface.
type MockAuthenticatable struct {
	ctrl     *gomock.Controller
	recorder *MockAuthenticatableMockRecorder
}

// MockAuthenticatableMockRecorder is the mock recorder for MockAuthenticatable.
type MockAuthenticatableMockRecorder struct {
	mock *MockAuthenticatable
}

// NewMockAuthenticatable creates a new mock instance.
func NewMockAuthenticatable(ctrl *gomock.Controller) *MockAuthenticatable {
	mock := &MockAuthenticatable{ctrl: ctrl}
	mock.recorder = &MockAuthenticatableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthenticatable) EXPECT() *MockAuthenticatableMockRecorder {
	return m.recorder
}

// Authenticate mocks base method.
func (m *MockAuthenticatable) Authenticate(auth sasl.Client) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Authenticate", auth)
	ret0, _ := ret[0].(error)
	return ret0
}

// Authenticate indicates an expected call of Authenticate.
func (mr *MockAuthenticatableMockRecorder) Authenticate(auth interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Authenticate", reflect.TypeOf((*MockAuthenticatable)(nil).Authenticate), auth)
}

// Login mocks base method.
func (m *MockAuthenticatable) Login(username, password string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Login", username, password)
	ret0, _ := ret[0].(error)
	return ret0
}

// Login indicates an expected call of Login.
func (mr *MockAuthenticatableMockRecorder) Login(username, password interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Login", reflect.TypeOf((*MockAuthenticatable)(nil).Login), username, password)
}

// MockAuthenticator is a mock of Authenticator interface.
type MockAuthenticator struct {
	ctrl     *gomock.Controller
	recorder *MockAuthenticatorMockRecorder
}

// MockAuthenticatorMockRecorder is the mock recorder for MockAuthenticator.
type MockAuthenticatorMockRecorder struct {
	mock *MockAuthenticator
}

// NewMockAuthenticator creates a new mock instance.
func NewMockAuthenticator(ctrl *gomock.Controller) *MockAuthenticator {
	mock := &MockAuthenticator{ctrl: ctrl}
	mock.recorder = &MockAuthenticatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthenticator) EXPECT() *MockAuthenticatorMockRecorder {
	return m.recorder
}

// Authenticate mocks base method.
func (m *MockAuthenticator) Authenticate(a imap0.Authenticatable) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Authenticate", a)
	ret0, _ := ret[0].(error)
	return ret0
}

// Authenticate indicates an expected call of Authenticate.
func (mr *MockAuthenticatorMockRecorder) Authenticate(a interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Authenticate", reflect.TypeOf((*MockAuthenticator)(nil).Authenticate), a)
}

// MockFactory is a mock of Factory interface.
type MockFactory struct {
	ctrl     *gomock.Controller
	recorder *MockFactoryMockRecorder
}

// MockFactoryMockRecorder is the mock recorder for MockFactory.
type MockFactoryMockRecorder struct {
	mock *MockFactory
}

// NewMockFactory creates a new mock instance.
func NewMockFactory(ctrl *gomock.Controller) *MockFactory {
	mock := &MockFactory{ctrl: ctrl}
	mock.recorder = &MockFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFactory) EXPECT() *MockFactoryMockRecorder {
	return m.recorder
}

// NewClient mocks base method.
func (m *MockFactory) NewClient(cfg *imap0.ClientConfig) (imap0.Client, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewClient", cfg)
	ret0, _ := ret[0].(imap0.Client)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewClient indicates an expected call of NewClient.
func (mr *MockFactoryMockRecorder) NewClient(cfg interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewClient", reflect.TypeOf((*MockFactory)(nil).NewClient), cfg)
}
